---
title: "Email Auth & Recovery"
description: "Email Authentication enables users to authenticate and recover their Turnkey accounts using email-based verification. There are two methods of email authentication:"
---

**One-Time Password**

- Uses a 6-9 digit or bech32 alphanumeric one-time password sent via email
- Simple, and familiar user experience

**Credential Bundle**

- Sends an encrypted API key credential directly via email
- Alternative method for specific use cases
- More secure, but requires copying the full credential to the client

Both methods provide users with an expiring API key for authentication or account recovery.

## Core Mechanism

Email Authentication is built with expiring API keys as the foundation. The two delivery mechanisms are:

### OTP-based Method

The authentication process happens in three steps:

<Steps>
  <Step>
    A 6-9 digit or alphanumeric OTP code is sent to the user's verified email
    address
  </Step>
  <Step>
    Upon verification of the correct code, a verification token is generated
  </Step>
  <Step>
    The verification token used to create a persistent session on the client side
  </Step>
</Steps>

### Credential Bundle Method

The API key credential is encrypted and delivered directly through email to the user.
Once the credential is live on the client side (within the context of an iframe), it is readily available to stamp (authenticate) requests. See the [enclave to end-user secure channel](/security/enclave-secure-channels) for more info on how we achieve secure delivery.

**Note:** this method is only supported with legacy iframe-based flow, if no hard requirement, we suggest to use the IndexedDB-based OTP flow instead.

## Prerequisites

Make sure you have set up your primary Turnkey organization with at least one API user that can programmatically initiate email auth on behalf of suborgs. Check out our [Quickstart guide](/getting-started/quickstart) if you need help getting started. To allow an API user to initiate email auth, you'll need the following policy in your main organization:

```json
{
  "effect": "EFFECT_ALLOW",
  "consensus": "approvers.any(user, user.id == '<YOUR_API_USER_ID>')",
  "condition": "activity.resource in ['AUTH', 'OTP'] && activity.action in ['CREATE','VERIFY']"
}
```

## User Experience

### OTP-based Authentication Flow

All the three steps below are being signed by the parent organization user:

<Steps>
  <Step>
  The user (on the client side) passes the email or phone number to the backend where the parent organziation sends the OTP code to the user's mailbox or phone number.
  This is an activity of type `ACTIVITY_TYPE_INIT_OTP` with these parameters:
  - `otpType`: specify `OTP_TYPE_EMAIL` or `OTP_TYPE_SMS`
  - `contact`: user's email address (must match their registered email)
  - `emailCustomization`: optional parameters for customizing emails
  - `smsCustomization` : optional parameters for customizing SMS
  - `userIdentifier`: optional parameter for rate limiting SMS OTP requests per user. We recommend generating this server-side based on the user's IP address or public key. See the [OTP Rate Limits](#otp-rate-limits) section below for more details.
  - `alphanumeric`: optional parameter for making this code bech32 alphanumeric or not. default: true
  - `otpLength`: optional parameter for selecting the length of the OTP. default: 9
  - `sendFromEmailAddress` : optional custom email address from which to send the OTP email
  - `sendFromEmailSenderName` : optional custom sender name for use with sendFromEmailAddress; if left empty, will default to ‘Notifications’
  - `expirationSeconds` : expiration window (in seconds) indicating how long the OTP is valid for (defaults to 5 minutes)
  - `replyToEmailAddress` : optional custom email address to use as reply-to
 </Step>
 <Step>
  After receiving the OTP, the user is passing it back to the backend, the parent organization user initiates `ACTIVITY_TYPE_VERIFY_OTP` and returns a JWT confirming that the email/phone number is verified:
  - `otpId`: ID from the init activity
  - `otpCode`: the 6-9 digit or alphanumeric code received via email
  - `expirationSeconds`: Expiration window (in seconds) indicating how long the verification token is valid for (defaults to 1 hour) 

  <Frame>
    <img
      src="/images/authentication/img/auth_otp_email.png"
      alt="auth otp email"
    />
  </Frame>
 </Step>
 <Step>
  The parent organization initiates `ACTIVITY_TYPE_OTP_LOGIN` to target a specific organization id and create a session. It's passing the the JWT token from verify OTP activity, along with the public key of the indexedDbClient (passed from the Frontend) and an organization id.
  A session JWT is returned with expiry date and the public key in indexedDb is added to organization data.
  - `verificationToken` : Signed JWT returned by the verify activity containing a unique id, expiry, verification type, contact
  - `publicKey` : Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token
  - `expirationSeconds` : Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  - `invalidateExisting` : Invalidate all other previously generated Login API keys
 </Step>
</Steps>

### OTP Rate Limits

In order to safeguard users, Turnkey enforces rate limits for OTP auth activities. If a `userIdentifier` parameter is provided, the following limits are enforced:

- 3 requests per 3 minutes per unique `userIdentifier`
- 3 retries max per code, after which point that code will be locked
- 3 active codes per user, each with a 5 minute TTL

### Credential Bundle Authentication Flow

This alternative method uses `ACTIVITY_TYPE_EMAIL_AUTH` with these parameters:

- `email`: user's email address (must match their registered email)
- `targetPublicKey`: public key for credential encryption
- `apiKeyName`: optional name (defaults to `Email Auth - <Timestamp>`)
- `expirationSeconds`: optional validity window (defaults to 15 minutes)
- `emailCustomization`: optional parameters for customizing emails
- `invalidateExisting`: optional boolean to invalidate previous Email Auth API keys

<Frame>
  <img src="/images/authentication/img/auth_email.png" alt="auth email" />
</Frame>

## Email Customization

We offer customization for the following:

- `appName`: the name of the application. This will be used in the email's subject, e.g. `Sign in to ${appName}`
- `logoUrl`: a link to a PNG with a max width of 340px and max height of 124px
- `magicLinkTemplate`: a template for the URL to be used in the magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`

```js
// Sign and submits the EMAIL_AUTH activity
const response = await client.emailAuth({
  type: "ACTIVITY_TYPE_EMAIL_AUTH",
  timestampMs: String(Date.now()),
  organizationId: <sub-organization-id>,
  parameters: {
    email: <user-email>,
    targetPublicKey: <iframe-public-key>,
    apiKeyName: <optional-api-key-name>,
    expirationSeconds: <optional-api-key-expiration-in-seconds>,
    emailCustomization: {
      appName: <optional-your-app-name>,
      logoUrl: <optional-your-logo-png>,
      magicLinkTemplate: <optional-magic-link>
    }
  },
});
```

### Email Templates

We also support custom HTML email templates for [Enterprise](https://www.turnkey.com/pricing) clients on the **Scale** tier. This allows you to inject arbitrary data from a JSON string containing key-value pairs. In this case, the `emailCustomization` variable may look like:

```js
...
emailCustomization: {
  templateId: <HTML-template-stored-in-turnkey>,
  templateVariables: "{\"username\": \"alice and bob\"}"
}
...
```

In this specific example, the value `alice and bob` can be interpolated into the email template using the key `username`. The use of such template variables is purely optional.

Here's an example of a custom HTML email containing an email auth bundle:

<Frame>
  ![dynamic email auth
  example](/images/embedded-wallets/img/email-auth-example-dynamic.png)
</Frame>

If you are interested in implementing bespoke, fully-customized email templates, please reach out to [hello@turnkey.com](mailto:hello@turnkey.com).

## Authorization

Authorization is managed through our [policy engine](/concepts/policies/overview):

### Authentication

Both OTP-based and credential bundle authentication activities:

- Can be performed by [root users](/concepts/overview#users) and users with proper policy authorization
- Require the respective feature to be enabled in the organization and sub-organization
- Can target any user in the organization or sub-organizations

Specifically:

- For OTP-based auth: `ACTIVITY_TYPE_INIT_OTP`, `ACTIVITY_TYPE_VERIFY_OTP` and `ACTIVITY_TYPE_OTP_LOGIN`
- For credential bundle auth: `ACTIVITY_TYPE_EMAIL_AUTH`

## Implementation in Sub-organizations

Both authentication methods work seamlessly with [sub-organizations](/concepts/sub-organizations).

### Example Implementations

- [OTP Auth Example](https://github.com/tkhq/sdk/tree/main/examples/otp-auth)
- [Email Auth Example](https://github.com/tkhq/sdk/tree/main/examples/email-auth)
- [Demo Embedded Wallet](https://wallet.tx.xyz) ([code](https://github.com/tkhq/demo-embedded-wallet))

## Implementation in Organizations

For organizations accessed via dashboard:

1. Ensure the required features are enabled:

   - `FEATURE_NAME_OTP_EMAIL_AUTH` for OTP-based authentication
   - `FEATURE_NAME_EMAIL_AUTH` for credential bundle authentication

2. Users initiating the request must have appropriate permissions

## Opting Out

Organizations can disable email-based features if their security model requires it:

Use `ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE` to disable:

- `FEATURE_NAME_OTP_EMAIL_AUTH` for OTP-based authentication
- `FEATURE_NAME_EMAIL_AUTH` for credential bundle authentication

When creating sub-organizations, use:

- `disableOtpEmailAuth` parameter for OTP-based authentication
- `disableEmailAuth` parameter for credential bundle authentication

## Implementation Notes[​](#implementation-notes "Direct link to Implementation Notes")

- Users are limited to:

  - 10 long-lived API keys
  - 10 expiring API keys (oldest are discarded when limit is reached)

### For Top-level Organizations

- Both authentication methods are disabled by default
- Must be enabled via `ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE`

### For Sub-organizations

- Both authentication methods are enabled by default
- Can be disabled during creation using `CreateSubOrganizationIntentV7` activity parameters

Example of enabling OTP-based Email Auth:

```bash
turnkey request --host api.turnkey.com --path /public/v1/submit/set_organization_feature --body '{
        "timestampMs": "'"$(date +%s)"'000",
        "type": "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE",
        "organizationId": "<YOUR-ORG-ID>",
        "parameters": {
                "name": "FEATURE_NAME_OTP_EMAIL_AUTH"
        }
}' --organization <YOUR-ORG-ID>
```

Example of enabling credential bundle Email Auth:

```bash
turnkey request --host api.turnkey.com --path /public/v1/submit/set_organization_feature --body '{
        "timestampMs": "'"$(date +%s)"'000",
        "type": "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE",
        "organizationId": "<YOUR-ORG-ID>",
        "parameters": {
                "name": "FEATURE_NAME_EMAIL_AUTH"
        }
}' --organization <YOUR-ORG-ID>
```

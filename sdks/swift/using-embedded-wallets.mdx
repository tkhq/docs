---
title: "Using embedded wallets"
description: "Learn how to create and manage embedded wallets in your iOS app using the Turnkey Swift SDK."
sidebarTitle: "Using embedded wallets"
---

## Overview

The Turnkey Swift SDK provides a straightforward way to create and manage embedded wallets in your iOS application. You can create wallets, derive accounts, import/export, and refresh wallet state from `TurnkeyContext`.

Before you start, make sure you're familiar with [Wallets](/concepts/wallets) and [Wallet Accounts](/concepts/wallets#accounts).

## Creating an embedded wallet

After your user has authenticated, create an embedded wallet by calling `createWallet` on `TurnkeyContext`. The example below creates a wallet with one Ethereum account.

```swift
import SwiftUI
import TurnkeySwift

struct CreateWalletButton: View {
  @EnvironmentObject private var turnkey: TurnkeyContext

  var body: some View {
    Button("Create Wallet") {
      Task {
        do {
          let accounts: [WalletAccountParams] = [
            WalletAccountParams(
              addressFormat: .address_format_ethereum,
              curve: .curve_secp256k1,
              path: "m/44'/60'/0'/0/0",
              pathFormat: .path_format_bip32
            )
          ]
          try await turnkey.createWallet(
            walletName: "My New Wallet",
            accounts: accounts
          )
        } catch {
          print("Error creating wallet:", error)
        }
      }
    }
  }
}
```

## Listing wallets in the UI

The `TurnkeyContext` maintains `wallets` for the active session. You can render them in your SwiftUI views:

```swift
import SwiftUI
import TurnkeySwift

struct WalletList: View {
  @EnvironmentObject private var turnkey: TurnkeyContext

  var body: some View {
    List(turnkey.wallets, id: \.walletId) { wallet in
      VStack(alignment: .leading) {
        Text(wallet.walletName)
        Text(wallet.walletId).font(.caption).foregroundColor(.gray)
      }
    }
  }
}
```

## Refreshing wallets

Call `refreshWallets()` to re-fetch wallets and accounts for the current session:

```swift
Task {
  try? await turnkey.refreshWallets()
}
```

## Creating wallet accounts

You can derive additional addresses for an existing wallet using the HTTP client:

```swift
import TurnkeyHttp
import TurnkeyTypes
import TurnkeySwift

guard
  let client = TurnkeyContext.shared.client,
  let orgId = TurnkeyContext.shared.session?.organizationId
else { return }

let newAccounts: [WalletAccountParams] = [
  WalletAccountParams(
    addressFormat: .address_format_ethereum,
    curve: .curve_secp256k1,
    path: "m/44'/60'/0'/0/1",
    pathFormat: .path_format_bip32
  )
]

_ = try await client.createWalletAccounts(TCreateWalletAccountsBody(
  organizationId: orgId,
  accounts: newAccounts,
  walletId: "<wallet_id_here>"
))
```

## Importing and exporting wallets

The Swift SDK lets you securely import/export wallets, accounts, and private keys. You can return decrypted values for developer workflows or handle encrypted bundles explicitly.

### Export (wallet)

Default: decrypt locally and return the mnemonic (developer-friendly).

```swift
import TurnkeySwift

let mnemonic = try await turnkey.exportWallet(walletId: "<wallet_id>")
// Do not display secrets in production UIs
```

Advanced (encrypted bundle): call the HTTP client directly and store or decrypt later.

```swift
import TurnkeyHttp
import TurnkeyCrypto
import TurnkeySwift

let (targetPublicKey, _, embeddedPrivateKey) = TurnkeyCrypto.generateP256KeyPair()

guard
  let client = TurnkeyContext.shared.client,
  let orgId = TurnkeyContext.shared.session?.organizationId
else { throw NSError(domain: "Turnkey", code: -1) }

let exportResp = try await client.exportWallet(TExportWalletBody(
  organizationId: orgId,
  targetPublicKey: targetPublicKey,
  walletId: "<wallet_id>"
))

let bundle = exportResp.exportBundle
// Decrypt later if needed:
// let decrypted = try TurnkeyCrypto.decryptExportBundle(
//   exportBundle: bundle,
//   organizationId: orgId,
//   embeddedPrivateKey: embeddedPrivateKey,
//   dangerouslyOverrideSignerPublicKey: nil,
//   returnMnemonic: true
// )
```

### Export (wallet account)

```swift
import TurnkeyHttp
import TurnkeyCrypto
import TurnkeySwift

let (targetPublicKey, _, _) = TurnkeyCrypto.generateP256KeyPair()

guard
  let client = TurnkeyContext.shared.client,
  let orgId = TurnkeyContext.shared.session?.organizationId
else { return }

let resp = try await client.exportWalletAccount(TExportWalletAccountBody(
  organizationId: orgId,
  address: "<wallet_account_address>",
  targetPublicKey: targetPublicKey
))

let exportBundle = resp.exportBundle
```

### Export (private key)

```swift
import TurnkeyHttp
import TurnkeyCrypto
import TurnkeySwift

let (targetPublicKey, _, _) = TurnkeyCrypto.generateP256KeyPair()

guard
  let client = TurnkeyContext.shared.client,
  let orgId = TurnkeyContext.shared.session?.organizationId
else { return }

let resp = try await client.exportPrivateKey(TExportPrivateKeyBody(
  organizationId: orgId,
  privateKeyId: "<private_key_id>",
  targetPublicKey: targetPublicKey
))

let exportBundle = resp.exportBundle
```

### Import (wallet)

Imports a wallet from a mnemonic and automatically refreshes local state.

```swift
import TurnkeySwift

let accounts: [WalletAccountParams] = [
  WalletAccountParams(
    addressFormat: .address_format_ethereum,
    curve: .curve_secp256k1,
    path: "m/44'/60'/0'/0/0",
    pathFormat: .path_format_bip32
  )
]

let walletId = try await turnkey.importWallet(
  walletName: "Imported Wallet",
  mnemonic: "<mnemonic>",
  accounts: accounts
)
```

### Import (private key)

```swift
import TurnkeyHttp
import TurnkeySwift

guard
  let client = TurnkeyContext.shared.client,
  let orgId = TurnkeyContext.shared.session?.organizationId
else { return }

let resp = try await client.importPrivateKey(TImportPrivateKeyBody(
  organizationId: orgId,
  privateKey: "<hex-or-base58-key>",
  privateKeyName: "My Key",
  addressFormats: [.address_format_ethereum]
))
let privateKeyId = resp.privateKeyId
```

## Next steps

Check out the [Signing](/sdks/swift/signing) guide to learn how to sign transactions and messages with the embedded wallets you've created.

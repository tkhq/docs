---
title: "Turnkey Verified"
---

## Turnkey Verified

Turnkey Verified is a new feature launched in Turnkey's dashboard and [Embedded Wallet Kit](../reference/embedded-wallet-kit.mdx).

As outlined in our [Whitepaper](https://whitepaper.turnkey.com/foundations#boot-proofs-and-app-proofs), Turnkey deploys software in secure enclaves and can remotely attest to the software running inside of them. We've done this since day one, internally: remote attestations are at the core of our deployment process and are a crucial tool to ensure Turnkey operators are provisioning enclaves with the correct configuration.

For the first time we're exposing proofs produced by our TEEs to the outside world. Turnkey's infrastructure produces two types of proofs:
* **Boot Proof**: a proof that a particular AWS Nitro Enclave has booted with a particular configuration. A boot proof contains:
  * An AWS attestation document, which contains AWS-level information: [PCR measurements](https://docs.aws.amazon.com/enclaves/latest/user/set-up-attestation.html#where), certificate chain, public key, and user data.
  * A signed [QOS manifest](https://github.com/tkhq/qos/blob/f773bb8fbe0b84c93c585f1ab10882fb570d8005/src/qos_core/src/protocol/services/boot.rs#L310-L327) which contains information about the application running in this particular enclave: binary hash and arguments, operator public keys, quorum public key, and more.
* **App Proofs**: a signature produced by an enclave Ephemeral Key (more on this below) to prove application-specific facts about functionality

### Use-cases

Boot proofs are application-agnostic. They are here to prove 2 things:
* **Prove that a particular machine is a legitimate AWS Nitro Enclave**. This is done by verifying the signature of the attestation and the associated certificate bundle: it contains a chain of certificates going up to the root certificate for the commercial AWS partitions (can be downloaded from https://aws-nitro-enclaves.amazonaws.com/AWS_NitroEnclaves_Root-G1.zip).
* **Prove that a particular machine is running within Turnkey's AWS account**. This can be verified by looking at the `PCR3` measurement inside of the AWS attestation document. It should be `b798abfdbd591d5e1b7db6485a6de9e65100f5796d9e3a2bd7c179989cd663338b567162974974fbcc45d03847e70d8b` (this is the sha384 digest of the parent instance role: `arn:aws:iam::705331783682:role/talos-worker` -- yes, Turnkey uses a [Talos](https://www.talos.dev/)-based Kubernetes cluster to deploy software)
* **Prove that a particular machine runs the correct, expected software**. This can be verified in a couple of steps:
  * Verify that PCR0, PCR1, and PCR2 values are correct and match a known QOS version (you can [reproduce these hashes yourself](https://github.com/tkhq/qos?tab=readme-ov-file#reproducing-builds) or look at our tkhq/core-enclaves repository for known good values)
  * Verify that the AWS attestation document's "user_data" is the digest of the QOS manifest
  * Parse the QOS manifest and inspect the application configuration to find the binary digest (and reference this digest against known good digests published in our tkhq/core-enclaves repository)

App proofs are application-specific. Once an enclave boots, it creates a unique Ephemeral Key which never leaves the enclave. As a result, data signed by an Ephemeral key proves that it was signed in a particular machine. App proofs and Boot Proofs are linked together by the "public_key" field of the AWS attestation document. Verifying an app proof involves 2 steps:
* Verify the app proof signature field against the public key field
* Verify that the public key (which signed the app proof) is the public key in the boot proof.

We envision applications need to prove many different types of facts about processed inputs, or about outputs, or both. For this reason we're standardizing app proof content to be strictly typed: each app proof has a well-defined type, and a well-defined schema. App proofs are JSON payloads, serialized and signed by enclave Ephemeral Keys.

The use-case we're starting with is **address derivation**. Here's a dummy App Proof payload:
```json
{
  "type": "APP_PROOF_TYPE_ADDRESS_DERIVATION",
  "timestampMs": "1758909116",
  "addressDerivationProof": {
    "organizationId": "your-organization-id",
    "walletId": "your-wallet-id",
    "derivationPath": "m/44'/60'/0'/0/0",
    "address": "0x61f4Ec0630DD50F1393cbDB60e5ccA1ed98f5100"
  }
}
```

By combining App Proof and Boot Proof verification, Turnkey Verified guarantees that your crypto address was derived:
* in the context of your Turnkey organization
* with Turnkey's signer application
* inside of a legitimate and precise version of [QuorumOS](https://github.com/tkhq/qos)
* inside of a legitimate [AWS Nitro Enclave](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html)
* inside Turnkey's canonical AWS production account

### Verifying proofs

We have written open-source code in our Rust and Typescript SDK to verify app proofs and boot proofs. This logic powers the "Verified" UI component you'll see when new address are derived on our Embedded Wallet Kit or through Turnkey's dashboard.

Feel free to inspect this code and run it locally on your own hardware, and reach out if you run into bugs or if you have further questions!

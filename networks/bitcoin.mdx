---
title: "Bitcoin support on Turnkey"
sidebarTitle: "Bitcoin"
---

## BIP32 and BIP44: the basis for Turnkey wallets

[BIP32](https://en.bitcoin.it/wiki/BIP_0032) and [BIP44](https://en.bitcoin.it/wiki/BIP_0044) are standards developed in the Bitcoin ecosystem. Turnkey closely follows this to power [Wallets](/concepts/wallets) since they're adopted within Bitcoin and outside, spanning many other ecosystems.

## BIP39: mnemonics

Turnkey supports importing and exporting keys in mnemonics form, following [BIP39](https://en.bitcoin.it/wiki/BIP_0039). This standard is now a de-facto standard across virtually all blockchains today.

## Address derivation

You can derive Bitcoin addresses when creating a Turnkey wallet or private key. The address types we support currently:

* P2PKH (Pay-To-Public-Key-Hash)
* P2SH (Pay-To-Script-Hash)
* P2WPKH (Pay-to-Witness-Public-Key-Hash) -- [segwit-enabled](https://learnmeabitcoin.com/technical/upgrades/segregated-witness/)
* P2WSH (Pay-to-Witness-Script-Hash) -- [segwit-enabled](https://learnmeabitcoin.com/technical/upgrades/segregated-witness/)
* P2TR (Pay-to-Taproot) -- [taproot-enabled](https://cointelegraph.com/learn/a-beginners-guide-to-the-bitcoin-taproot-upgrade)

Bitcoin addresses change depending on the network you're using (more precisely, their prefix!). When you derive an address the network will be part of the address format. We support the following networks:

* Mainnet (`MAINNET`)
* Testnet (`TESTNET`)
* Regtest (`REGTEST`)
* Signet (`SIGNET`)

For example:

* To derive a P2TR address on testnet, use `ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR`.
* To derive a P2SH address on mainnet, use `ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH`.

## Schnorr signatures and tweaks

The historical signature scheme for Bitcoin is [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm). Turnkey supports ECDSA of course, but we also support [Schnorr signatures](https://en.wikipedia.org/wiki/Schnorr_signature) for Taproot addresses.

To sign with Schnorr, pass a taproot (P2TR) address inside of your activity's `signWith` parameter. Turnkey's signer will switch to Schnorr and apply the correct cryptographic [tweak](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs) before signing.

##  Policy-Enabled Bitcoin Transaction Signing

Turnkey has built a Bitcoin transaction parser which runs in a secure enclave, to enable bitcoin based policies in the policy engine. 

To enable more policy engine use cases, and facilitate transaction construction completely, policy-enabled bitcoin transactions requires passing a hex serialized representation of a Partially Signed Bitcoin Transaction (PSBT) to our `SIGN_TRANSACTION` endpoint using the transaction type `TRANSACTION_TYPE_BITCOIN`. 

### What are PSBT’s and why do we use them

Partially signed bitcoin transaction or PSBT is a data format for passing around bitcoin transactions to signing services. The PSBT format contains raw unsigned transaction data, along with extra “context” data required to get the transaction signed. Most modern wallets support and use PSBT’s for transaction signing. 

For Turnkey’s policy-enabled bitcoin transaction signing flow, PSBT’s provide the context needed for the policy engine to make decisions based on transaction content, to generate the actual payloads that need to be signed (sighashes) and to reinsert those sighashes in the correct place. 

For more information on PSBT’s look here: https://learnmeabitcoin.com/technical/transaction/psbt/

### How to use Turnkey’s Policy-Enabled Bitcoin Transaction signing flow 

The transaction signing flow works as follows: 
* Client creates bitcoin policies for enabling or restriction transaction signing using the `bitcoin.tx` namespace. For reference look at the Policy Launguage documentation [language section](/concepts/policies/language#bitcoin) or the [Bitcoin policy examples](/concepts/policies/examples#bitcoin) documentation
* Client constructs a PSBT (using a library like bitcoinjs-lib[https://github.com/bitcoinjs/bitcoinjs-lib]) representing the transaction they need signed, hex serializes it and passes in the string of the hex representation of the PSBT into Turnkey’s Sign Transaction Endpoint with type: TRANSACTION_TYPE_BITCOIN
* The `SIGN TRANSACTION` endpoint constructs the sighashes ONLY for inputs which are to be signed by the signing resource which was specified in the `SIGN TRANSACTION` request, and based on policy evaluation, signs these sighashes and reinserts them into the correct corresponding inputs in the PSBT. For more details on how reinsertion works across each address derivation type, look below. 
* Client receives hex representation of PSBT with reinserted signatures, continues signing process for other inputs if needed, finalizes inputs and broadcasts. 


### Technical Specifics on Turnkey's Bitcoin Transaction Signing Support

Turnkey supports policy-enabled transaction signing for inputs on the following address derivation types: P2PKH, P2SH, P2WPKH, P2WSH and P2TR. Notably, we do not support reinsertion according to wrapped types like P2SH-P2WPKH and P2SH-P2WSH.

For specific technical context on how Turnkey does reinsertion across address types: 

#### P2PKH, P2SH, P2WPKH, P2WSH

For Legacy and Segwit Bitcoin address derivation types, for each input corresponding to the Turnkey signing resource specified in the `SIGN TRANSACTION` call, Turnkey constructs the DER encoded signature of the sighash and reinserts it into the Partial Signatures field of each relevant input in the PSBT, corresponding to the public key of the signing resource. 

NOTE: For constructing and reinserting sighashes for Legacy and Segwith Bitcoin address derivation types, by default, we use the sighash type SIGHASH_ALL as is the convention for these types. 

Context on Sighash types, conventions, and how it affects signing can be found on learn me a bitcoin’s signature page: https://learnmeabitcoin.com/technical/keys/signature/

#### P2TR

Turnkey supports transaction reinsertion bitcoin transactions with P2TR inputs for Key Path signing ONLY. At the moment we do not support reinsertion for Taproot script path signing. For Taproot Key Path signing, for each input corresponding to the Turnkey signing resource specified in the `SIGN TRANSACTION` call, Turnkey constructs the schnorr signature of the sighash and reinserts it into the Taproot Key Spend Signature field of each relevant input in the PSBT.

NOTE: For constructing and reinserting sighashes for Taproot Bitcoin address derivation types, by default, we use the sighash type SIGHASH_DEFAULT type as is the convention.

Context on signing, and sighash conventions for Taproot can be found on learn me a bitcoin’s Taproot page: https://learnmeabitcoin.com/technical/upgrades/taproot/


## SDK example

If you want to get started with Bitcoin we encourage you to look at the following SDK example: [`examples/with-bitcoin`](https://github.com/tkhq/sdk/tree/main/examples/with-bitcoin). It showcases transaction construction and signing with [`bitcoinjs-lib`](https://github.com/bitcoinjs/bitcoinjs-lib), a widely used JS library.

This demo contains a client-side [signer](https://github.com/tkhq/sdk/blob/main/examples/with-bitcoin/src/signer.ts) which seamlessly integrates Turnkey signing with this library for both taproot and non-taproot output signatures. Let us know if you're interested in using it. We have not yet published it as a standalone NPM package, but could do it if we hear enough interest!



